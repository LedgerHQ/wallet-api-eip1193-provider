import Transport from "@ledgerhq/hw-transport";
import { RpcError, schemaDeviceClose, schemaDeviceExchange, } from "@ledgerhq/wallet-api-core";
/**
 * Wallet API Transport implementation
 */
export class TransportWalletAPI extends Transport {
    walletApi;
    transportId;
    constructor(walletApi, transportId) {
        super();
        this.transportId = transportId;
        this.walletApi = walletApi;
    }
    /**
     * Check if Wallet API transport is supported.
     */
    static isSupported = () => Promise.resolve(true);
    /**
     * This transport is not discoverable
     */
    static list = () => Promise.resolve([]);
    static listen = (_observer) => ({
        unsubscribe: () => { },
    });
    /**
     * Create a Ledger transport with the Wallet API transport
     */
    static open({ walletApi, transportId, }) {
        return Promise.resolve(new TransportWalletAPI(walletApi, transportId));
    }
    /**
     * Exchange with the device using APDU protocol.
     * @param apdu
     * @returns a promise of apdu response
     */
    async exchange(apdu) {
        const apduHex = apdu.toString("hex");
        const deviceExchangeResult = await this.walletApi.request("device.exchange", {
            transportId: this.transportId,
            apduHex,
        });
        if ("error" in deviceExchangeResult) {
            throw new RpcError(deviceExchangeResult.error);
        }
        const safeResults = schemaDeviceExchange.result.parse(deviceExchangeResult.result);
        return Buffer.from(safeResults.responseHex, "hex");
    }
    // eslint-disable-next-line class-methods-use-this
    setScrambleKey() { }
    async close() {
        const deviceCloseResult = await this.walletApi.request("device.close", {
            transportId: this.transportId,
        });
        if ("error" in deviceCloseResult) {
            throw new RpcError(deviceCloseResult.error);
        }
        schemaDeviceClose.result.parse(deviceCloseResult.result);
        // Should we check the transportId against the one from the class
        // and throw an error in case of mismatch ?
    }
}
