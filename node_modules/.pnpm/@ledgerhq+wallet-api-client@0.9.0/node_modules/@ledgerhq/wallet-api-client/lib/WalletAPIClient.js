"use strict";
// TODO: reimplement all methods
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletAPIClient = void 0;
const wallet_api_core_1 = require("@ledgerhq/wallet-api-core");
const TransportWalletAPI_1 = require("./TransportWalletAPI");
const defaultLogger = new wallet_api_core_1.Logger("LL-PlatformSDK");
// temporary
const requestHandlers = {
    "event.account.updated": async (_request) => {
        console.log("accounts updated !");
    },
};
class WalletAPIClient extends wallet_api_core_1.RpcNode {
    logger;
    constructor(transport, logger = defaultLogger) {
        super(transport, requestHandlers);
        this.logger = logger;
    }
    onRequest(request) {
        this.logger.log(request.method);
        const handler = this.requestHandlers[request.method];
        if (!handler) {
            throw new wallet_api_core_1.RpcError({
                code: wallet_api_core_1.RpcErrorCode.METHOD_NOT_FOUND,
                message: "method not found",
            });
        }
        return handler(request);
    }
    /**
     * Let the user sign a transaction that won't be broadcasted by the connected wallet
     * @param accountId - id of the account
     * @param transaction - The transaction object in the currency family-specific format
     * @param options - Extra parameters
     *
     * @returns The raw signed transaction
     */
    async signTransaction(accountId, transaction, options) {
        const transactionSignResult = await this.request("transaction.sign", {
            accountId,
            rawTransaction: (0, wallet_api_core_1.serializeTransaction)(transaction),
            options,
        });
        if ("error" in transactionSignResult) {
            throw new wallet_api_core_1.RpcError(transactionSignResult.error);
        }
        const safeResults = wallet_api_core_1.schemaTransactionSign.result.parse(transactionSignResult.result);
        return Buffer.from(safeResults.signedTransactionHex, "hex");
    }
    /**
     * Let the user sign and broadcast a transaction
     * @param accountId - id of the account
     * @param transaction - The transaction object in the currency family-specific format
     * @param options - Extra parameters
     *
     * @returns The transaction hash
     */
    async signTransactionAndBroadcast(accountId, transaction, options) {
        const transactionSignResult = await this.request("transaction.signAndBroadcast", {
            accountId,
            rawTransaction: (0, wallet_api_core_1.serializeTransaction)(transaction),
            options,
        });
        if ("error" in transactionSignResult) {
            throw new wallet_api_core_1.RpcError(transactionSignResult.error);
        }
        const safeResults = wallet_api_core_1.schemaTransactionSignAndBroadcast.result.parse(transactionSignResult.result);
        return safeResults.transactionHash;
    }
    /**
     * Let the user sign the provided message.
     * In Ethereum context, this is an [EIP-191 message](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-191.md) or an [EIP-712 message](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md)
     * @param accountId - Ledger Live id of the account
     * @param message - Message the user should sign
     *
     * @returns Message signed
     */
    async signMessage(accountId, message) {
        const messageSignResult = await this.request("message.sign", {
            accountId,
            hexMessage: message.toString("hex"),
        });
        if ("error" in messageSignResult) {
            throw new wallet_api_core_1.RpcError(messageSignResult.error);
        }
        const safeResults = wallet_api_core_1.schemaMessageSign.result.parse(messageSignResult.result);
        return Buffer.from(safeResults.hexSignedMessage, "hex");
    }
    /**
     * List accounts added by user on the connected wallet
     *
     * @returns The list of accounts on the connected wallet
     */
    async listAccounts(params) {
        const listAccountsResult = await this.request("account.list", {
            currencyIds: params?.currencyIds,
        });
        if ("error" in listAccountsResult) {
            throw new wallet_api_core_1.RpcError(listAccountsResult.error);
        }
        const safeResults = wallet_api_core_1.schemaAccountList.result.parse(listAccountsResult.result);
        return safeResults.rawAccounts.map(wallet_api_core_1.deserializeAccount);
    }
    /**
     * Ask the connected wallet for an account matching a specific set of critterias.
     *
     * @param params - Parameters of the request.
     *
     * @returns The account selected by the user
     */
    async requestAccount(params) {
        const requestAccountsResult = await this.request("account.request", {
            currencyIds: params?.currencyIds,
        });
        if ("error" in requestAccountsResult) {
            throw new wallet_api_core_1.RpcError(requestAccountsResult.error);
        }
        const safeResults = wallet_api_core_1.schemaAccountRequest.result.parse(requestAccountsResult.result);
        return (0, wallet_api_core_1.deserializeAccount)(safeResults.rawAccount);
    }
    /**
     * Let user verify it's account address on his device through Ledger Live
     *
     * @param accountId - id of the account
     *
     * @returns The verified address or an error message if the verification doesn't succeed
     */
    async receive(accountId) {
        const receiveAccountsResult = await this.request("account.receive", {
            accountId,
        });
        if ("error" in receiveAccountsResult) {
            throw new wallet_api_core_1.RpcError(receiveAccountsResult.error);
        }
        const safeResults = wallet_api_core_1.schemaAccountReceive.result.parse(receiveAccountsResult.result);
        return safeResults.address;
    }
    /**
     * List cryptocurrencies supported by the connected wallet, providing filters by name or ticker
     *
     * @param params - Filters for currencies
     *
     * @returns The list of corresponding cryptocurrencies
     *
     * @beta Filtering not yet implemented
     */
    async listCurrencies(params) {
        const listCurrenciesResult = await this.request("currency.list", {
            currencyIds: params?.currencyIds,
        });
        if ("error" in listCurrenciesResult) {
            throw new wallet_api_core_1.RpcError(listCurrenciesResult.error);
        }
        const safeResults = wallet_api_core_1.schemaCurrencyList.result.parse(listCurrenciesResult.result);
        return safeResults.currencies;
    }
    /**
     * Open low-level transport in the connected wallet
     *
     * @param params - Params for the transport
     *
     * @returns An instance of Transport compatible with @ledgerhq/hw-transport
     */
    async deviceTransport(params) {
        const deviceTransportResult = await this.request("device.transport", params);
        if ("error" in deviceTransportResult) {
            throw new wallet_api_core_1.RpcError(deviceTransportResult.error);
        }
        const safeResults = wallet_api_core_1.schemaDeviceTransport.result.parse(deviceTransportResult.result);
        return TransportWalletAPI_1.TransportWalletAPI.open({
            walletApi: this,
            transportId: safeResults.transportId,
        });
    }
    /*
     * List the wallet's implemented methodIds
     *
     * @returns The list of implemented method ids
     *
     * @beta Filtering not yet implemented
     */
    async capabilities() {
        const walletCapabilitiesResult = await this.request("wallet.capabilities", {});
        if ("error" in walletCapabilitiesResult) {
            throw new wallet_api_core_1.RpcError(walletCapabilitiesResult.error);
        }
        const safeResults = wallet_api_core_1.schemaWalletCapabilities.result.parse(walletCapabilitiesResult.result);
        return safeResults.methodIds;
    }
}
exports.WalletAPIClient = WalletAPIClient;
