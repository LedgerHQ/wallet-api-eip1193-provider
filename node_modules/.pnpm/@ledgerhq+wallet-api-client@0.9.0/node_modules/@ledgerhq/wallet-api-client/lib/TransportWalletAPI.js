"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransportWalletAPI = void 0;
const hw_transport_1 = __importDefault(require("@ledgerhq/hw-transport"));
const wallet_api_core_1 = require("@ledgerhq/wallet-api-core");
/**
 * Wallet API Transport implementation
 */
class TransportWalletAPI extends hw_transport_1.default {
    walletApi;
    transportId;
    constructor(walletApi, transportId) {
        super();
        this.transportId = transportId;
        this.walletApi = walletApi;
    }
    /**
     * Check if Wallet API transport is supported.
     */
    static isSupported = () => Promise.resolve(true);
    /**
     * This transport is not discoverable
     */
    static list = () => Promise.resolve([]);
    static listen = (_observer) => ({
        unsubscribe: () => { },
    });
    /**
     * Create a Ledger transport with the Wallet API transport
     */
    static open({ walletApi, transportId, }) {
        return Promise.resolve(new TransportWalletAPI(walletApi, transportId));
    }
    /**
     * Exchange with the device using APDU protocol.
     * @param apdu
     * @returns a promise of apdu response
     */
    async exchange(apdu) {
        const apduHex = apdu.toString("hex");
        const deviceExchangeResult = await this.walletApi.request("device.exchange", {
            transportId: this.transportId,
            apduHex,
        });
        if ("error" in deviceExchangeResult) {
            throw new wallet_api_core_1.RpcError(deviceExchangeResult.error);
        }
        const safeResults = wallet_api_core_1.schemaDeviceExchange.result.parse(deviceExchangeResult.result);
        return Buffer.from(safeResults.responseHex, "hex");
    }
    // eslint-disable-next-line class-methods-use-this
    setScrambleKey() { }
    async close() {
        const deviceCloseResult = await this.walletApi.request("device.close", {
            transportId: this.transportId,
        });
        if ("error" in deviceCloseResult) {
            throw new wallet_api_core_1.RpcError(deviceCloseResult.error);
        }
        wallet_api_core_1.schemaDeviceClose.result.parse(deviceCloseResult.result);
        // Should we check the transportId against the one from the class
        // and throw an error in case of mismatch ?
    }
}
exports.TransportWalletAPI = TransportWalletAPI;
