import { v4 as uuidv4 } from "uuid";
import { z } from "zod";
import { parseRPCCall, createRpcResponse } from "./helpers";
import { RpcError } from "./RPCError";
import { RpcErrorCode } from "./types";
export class RpcNode {
    transport;
    requestHandlers;
    ongoingRequests = {};
    constructor(transport, requestHandlers) {
        this.transport = transport;
        this.requestHandlers = requestHandlers;
        this.transport.onMessage = (message) => {
            void this.handleMessage(message);
        };
    }
    _request(request) {
        return new Promise((resolve) => {
            if (!request.id) {
                throw new Error("requests need to have an id");
            }
            const resolver = (response) => {
                if ("error" in response) {
                    throw new RpcError(response.error);
                }
                resolve(response);
            };
            this.ongoingRequests[request.id] = resolver;
            this.transport.send(JSON.stringify(request));
        });
    }
    _notify(request) {
        this.transport.send(JSON.stringify(request));
    }
    request(method, params) {
        const requestId = uuidv4();
        return this._request({
            id: requestId,
            jsonrpc: "2.0",
            method,
            params,
        });
    }
    notify(method, params) {
        return this._notify({
            jsonrpc: "2.0",
            method,
            params,
        });
    }
    async handleRpcRequest(request) {
        try {
            const result = await this.onRequest(request);
            if (request.id) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call
                const response = createRpcResponse({
                    id: request.id,
                    result,
                });
                this.transport.send(JSON.stringify(response));
            }
        }
        catch (error) {
            if (error instanceof z.ZodError) {
                throw new RpcError({
                    code: RpcErrorCode.INVALID_PARAMS,
                    message: error.message,
                    data: error.flatten(),
                });
            }
            throw error;
        }
    }
    async handleMessage(message) {
        let shouldReplyWithError = true;
        let callId;
        try {
            const rpcCall = parseRPCCall(message);
            callId = rpcCall.id;
            if ("method" in rpcCall) {
                // message is a request
                await this.handleRpcRequest(rpcCall);
            }
            else {
                // message is a response
                shouldReplyWithError = false;
                this.handleRpcResponse(rpcCall);
            }
        }
        catch (error) {
            if (shouldReplyWithError && error instanceof RpcError) {
                const errorResponse = createRpcResponse({
                    id: callId || null,
                    error: {
                        code: error.getCode(),
                        message: error.message,
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                        data: error.getData(),
                    },
                });
                this.transport.send(JSON.stringify(errorResponse));
                return;
            }
            throw error;
        }
    }
    handleRpcResponse(response) {
        if (!response.id) {
            return;
        }
        const resolver = this.ongoingRequests[response.id];
        if (!resolver) {
            throw new Error(`no ongoingRequest ${response.id}`);
        }
        resolver(response);
    }
}
