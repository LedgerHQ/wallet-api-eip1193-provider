"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcNode = void 0;
const uuid_1 = require("uuid");
const zod_1 = require("zod");
const helpers_1 = require("./helpers");
const RPCError_1 = require("./RPCError");
const types_1 = require("./types");
class RpcNode {
    transport;
    requestHandlers;
    ongoingRequests = {};
    constructor(transport, requestHandlers) {
        this.transport = transport;
        this.requestHandlers = requestHandlers;
        this.transport.onMessage = (message) => {
            void this.handleMessage(message);
        };
    }
    _request(request) {
        return new Promise((resolve) => {
            if (!request.id) {
                throw new Error("requests need to have an id");
            }
            const resolver = (response) => {
                if ("error" in response) {
                    throw new RPCError_1.RpcError(response.error);
                }
                resolve(response);
            };
            this.ongoingRequests[request.id] = resolver;
            this.transport.send(JSON.stringify(request));
        });
    }
    _notify(request) {
        this.transport.send(JSON.stringify(request));
    }
    request(method, params) {
        const requestId = (0, uuid_1.v4)();
        return this._request({
            id: requestId,
            jsonrpc: "2.0",
            method,
            params,
        });
    }
    notify(method, params) {
        return this._notify({
            jsonrpc: "2.0",
            method,
            params,
        });
    }
    async handleRpcRequest(request) {
        try {
            const result = await this.onRequest(request);
            if (request.id) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call
                const response = (0, helpers_1.createRpcResponse)({
                    id: request.id,
                    result,
                });
                this.transport.send(JSON.stringify(response));
            }
        }
        catch (error) {
            if (error instanceof zod_1.z.ZodError) {
                throw new RPCError_1.RpcError({
                    code: types_1.RpcErrorCode.INVALID_PARAMS,
                    message: error.message,
                    data: error.flatten(),
                });
            }
            throw error;
        }
    }
    async handleMessage(message) {
        let shouldReplyWithError = true;
        let callId;
        try {
            const rpcCall = (0, helpers_1.parseRPCCall)(message);
            callId = rpcCall.id;
            if ("method" in rpcCall) {
                // message is a request
                await this.handleRpcRequest(rpcCall);
            }
            else {
                // message is a response
                shouldReplyWithError = false;
                this.handleRpcResponse(rpcCall);
            }
        }
        catch (error) {
            if (shouldReplyWithError && error instanceof RPCError_1.RpcError) {
                const errorResponse = (0, helpers_1.createRpcResponse)({
                    id: callId || null,
                    error: {
                        code: error.getCode(),
                        message: error.message,
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                        data: error.getData(),
                    },
                });
                this.transport.send(JSON.stringify(errorResponse));
                return;
            }
            throw error;
        }
    }
    handleRpcResponse(response) {
        if (!response.id) {
            return;
        }
        const resolver = this.ongoingRequests[response.id];
        if (!resolver) {
            throw new Error(`no ongoingRequest ${response.id}`);
        }
        resolver(response);
    }
}
exports.RpcNode = RpcNode;
