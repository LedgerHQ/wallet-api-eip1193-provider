/// <reference types="node" />
import type HWTransport from "@ledgerhq/hw-transport";
import { Account, Currency, DeviceTransport, Logger, RpcNode, RpcRequest, Transaction, TransactionSign, TransactionSignAndBroadcast, Transport, WalletHandlers } from "@ledgerhq/wallet-api-core";
export declare type RPCHandler<Result> = (request: RpcRequest) => Promise<Result>;
declare const requestHandlers: {
    "event.account.updated": (_request: RpcRequest) => Promise<void>;
};
/**
 * WalletAPI Client which rely on WindowMessage communication
 */
export declare class WalletAPIClient extends RpcNode<typeof requestHandlers, WalletHandlers> {
    private logger;
    constructor(transport: Transport, logger?: Logger);
    protected onRequest(request: RpcRequest): Promise<void>;
    /**
     * Let the user sign a transaction that won't be broadcasted by the connected wallet
     * @param accountId - id of the account
     * @param transaction - The transaction object in the currency family-specific format
     * @param options - Extra parameters
     *
     * @returns The raw signed transaction
     * @throws {@link RpcError} if an error occured on server side
     */
    signTransaction(accountId: string, transaction: Transaction, options?: TransactionSign["params"]["options"]): Promise<Buffer>;
    /**
     * Let the user sign and broadcast a transaction
     * @param accountId - id of the account
     * @param transaction - The transaction object in the currency family-specific format
     * @param options - Extra parameters
     *
     * @returns The transaction hash
     * @throws {@link RpcError} if an error occured on server side
     */
    signTransactionAndBroadcast(accountId: string, transaction: Transaction, options?: TransactionSignAndBroadcast["params"]["options"]): Promise<string>;
    /**
     * Let the user sign the provided message.
     * In Ethereum context, this is an [EIP-191 message](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-191.md)
     * or an [EIP-712 message](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md)
     * @param accountId - Ledger Live id of the account
     * @param message - Message the user should sign
     *
     * @returns Message signed
     * @throws {@link RpcError} if an error occured on server side
     */
    signMessage(accountId: string, message: Buffer): Promise<Buffer>;
    /**
     * List accounts added by user on the connected wallet
     *
     * @param params - Filters for currencies
     *
     * @returns The list of accounts on the connected wallet
     * @throws {@link RpcError} if an error occured on server side
     */
    listAccounts(params?: {
        /**
         * Select a set of currencies by id to filter accounts against.
         */
        currencyIds?: string[];
    }): Promise<Account[]>;
    /**
     * Ask the connected wallet for an account matching a specific set of critterias.
     *
     * @param params - Parameters of the request.
     *
     * @returns The account selected by the user
     * @throws {@link RpcError} if an error occured on server side
     */
    requestAccount(params?: {
        /**
         * Select a set of currencies by id. Globing is enabled
         */
        currencyIds?: string[];
    }): Promise<Account>;
    /**
     * Let user verify it's account address on his device through Ledger Live
     *
     * @param accountId - id of the account
     *
     * @returns The verified address or an error message if the verification doesn't succeed
     */
    receive(accountId: string): Promise<string>;
    /**
     * List cryptocurrencies supported by the connected wallet, providing filters by name or ticker
     *
     * @param params - Filters for currencies
     *
     * @returns The list of corresponding cryptocurrencies
     * @throws {@link RpcError} if an error occured on server side
     *
     * @beta Filtering not yet implemented
     */
    listCurrencies(params?: {
        /**
         * Select a set of currencies by id. Globing is enabled
         */
        currencyIds?: string[];
    }): Promise<Currency[]>;
    /**
     * Open low-level transport in the connected wallet
     *
     * @param params - Params for the transport
     *
     * @returns An instance of Transport compatible with @ledgerhq/hw-transport
     * @throws {@link RpcError} if an error occured on server side
     */
    deviceTransport(params: DeviceTransport["params"]): Promise<HWTransport>;
    /**
     * List the wallet's implemented methodIds
     *
     * @returns The list of implemented method ids
     * @throws {@link RpcError} if an error occured on server side
     *
     * @beta Filtering not yet implemented
     */
    capabilities(): Promise<string[]>;
}
export {};
//# sourceMappingURL=WalletAPIClient.d.ts.map