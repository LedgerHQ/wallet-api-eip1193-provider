"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcNode = void 0;
const uuid_1 = require("uuid");
const zod_1 = require("zod");
const errors_1 = require("@ledgerhq/errors");
const errors_2 = require("../errors");
const helpers_1 = require("./helpers");
const RPCError_1 = require("./RPCError");
const types_1 = require("./types");
class RpcNode {
    transport;
    requestHandlers;
    ongoingRequests = {};
    constructor(transport, requestHandlers) {
        this.transport = transport;
        this.requestHandlers = requestHandlers;
        this.transport.onMessage = (message) => {
            void this.handleMessage(message);
        };
    }
    _request(request) {
        return new Promise((resolve, reject) => {
            if (!request.id) {
                reject(new Error("requests need to have an id"));
                return;
            }
            const resolver = (response) => {
                if ("error" in response) {
                    if (response.error.code === types_1.RpcErrorCode.SERVER_ERROR) {
                        const serverErrorData = errors_2.schemaServerErrorData.parse(response.error.data);
                        if (serverErrorData.code === "UNKNOWN_ERROR") {
                            reject((0, errors_1.deserializeError)(serverErrorData.data));
                            return;
                        }
                        reject(new errors_2.ServerError(serverErrorData));
                        return;
                    }
                    reject(new RPCError_1.RpcError(response.error));
                    return;
                }
                resolve(response.result);
            };
            this.ongoingRequests[request.id] = resolver;
            this.transport.send(JSON.stringify(request));
        });
    }
    _notify(request) {
        this.transport.send(JSON.stringify(request));
    }
    request(method, params) {
        const requestId = (0, uuid_1.v4)();
        return this._request({
            id: requestId,
            jsonrpc: "2.0",
            method,
            params,
        });
    }
    notify(method, params) {
        return this._notify({
            jsonrpc: "2.0",
            method,
            params,
        });
    }
    async handleRpcRequest(request) {
        try {
            const result = await this.onRequest(request);
            if (request.id) {
                const response = (0, helpers_1.createRpcResponse)({
                    id: request.id,
                    result,
                });
                this.transport.send(JSON.stringify(response));
            }
        }
        catch (error) {
            if (error instanceof zod_1.z.ZodError) {
                throw new RPCError_1.RpcError({
                    code: types_1.RpcErrorCode.INVALID_PARAMS,
                    message: error.message,
                    data: error.flatten(),
                });
            }
            if (error instanceof errors_2.ServerError) {
                throw new RPCError_1.RpcError({
                    code: types_1.RpcErrorCode.SERVER_ERROR,
                    message: "unexpected server error",
                    data: error.getData(),
                });
            }
            if (error instanceof RPCError_1.RpcError) {
                throw error;
            }
            throw new RPCError_1.RpcError({
                code: types_1.RpcErrorCode.SERVER_ERROR,
                message: "unexpected server error",
                // @ts-expect-error: Bad typings on serialize error !!
                data: (0, errors_2.createUnknownError)((0, errors_1.serializeError)(error)),
            });
        }
    }
    async handleMessage(message) {
        let isResponse = false;
        let callId;
        try {
            const rpcCall = (0, helpers_1.parseRPCCall)(message);
            callId = rpcCall.id;
            if ("method" in rpcCall) {
                // message is a request
                await this.handleRpcRequest(rpcCall);
            }
            else {
                // message is a response
                isResponse = true;
                this.handleRpcResponse(rpcCall);
            }
        }
        catch (error) {
            if (isResponse) {
                throw error;
            }
            if (error instanceof RPCError_1.RpcError) {
                const errorResponse = (0, helpers_1.createRpcResponse)({
                    id: callId || null,
                    error: {
                        code: error.getCode(),
                        message: error.message,
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                        data: error.getData(),
                    },
                });
                this.transport.send(JSON.stringify(errorResponse));
                return;
            }
            // TODO handle no RpcError (that should not happen btw)
            throw error;
        }
    }
    handleRpcResponse(response) {
        if (!response.id) {
            return;
        }
        const resolver = this.ongoingRequests[response.id];
        if (!resolver) {
            throw new Error(`no ongoingRequest ${response.id}`);
        }
        resolver(response);
    }
}
exports.RpcNode = RpcNode;
