import type { Transport } from "../transports";
import { RpcRequest } from "./types";
declare type ReturnTypeOfMethod<T> = T extends (...args: Array<unknown>) => unknown ? ReturnType<T> : unknown;
declare type ReturnTypeOfMethodIfExists<T, S> = S extends keyof T ? ReturnTypeOfMethod<T[S]> : unknown;
declare type MethodParams<T> = T extends (...args: infer P) => unknown ? P[0] : T;
declare type MethodParamsIfExists<T, S> = S extends keyof T ? MethodParams<T[S]> : S;
export declare abstract class RpcNode<TSHandlers, TCHandlers> {
    private transport;
    protected requestHandlers: TSHandlers;
    private ongoingRequests;
    constructor(transport: Transport, requestHandlers: TSHandlers);
    private _request;
    private _notify;
    request<K extends keyof TCHandlers>(method: K, params: MethodParamsIfExists<TCHandlers, K>): Promise<ReturnTypeOfMethodIfExists<TCHandlers, K>>;
    notify<K extends keyof TCHandlers>(method: K, params: MethodParamsIfExists<TCHandlers, K>): void;
    private handleRpcRequest;
    private handleMessage;
    protected abstract onRequest(request: RpcRequest): Promise<unknown>;
    private handleRpcResponse;
}
export {};
//# sourceMappingURL=RpcNode.d.ts.map